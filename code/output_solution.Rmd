---
title: "Output evaluation"
author: "Fabienne Lind"
date: "2023-02-12"
output: html_document
---



```{r setup, include=FALSE}

articles <- read.csv("https://raw.githubusercontent.com/fabiennelind/Workshop_Multilingual-Text-Analysis_and_Comparative-Research/master/data/climate_news.csv")


```

We have managed to get an automated measurement for the variable climate activism. **But how valid is this measurement?** Does our small set of keyword represent the concept adequately?

A common procedure in automated content analysis is to test construct validity. We ask:
How close is this automated measurement to a more trusted measurement: Human understanding of text.
Let's put this to practice. 

## Dictionary validation with a human coded baseline

To validate the dictionary, we compare the classifications of the dictionary with the classifications of human coders. 

We create the human coded baseline together. 

### Intercoder reliability test

To ensure the quality of our manual coding, we first perform a intercoder reliability test. For this tutorial, we select a random set of 20 articles. In a real study the number of observations coded by several coders should be higher.  

```{r}

colnames(articles)
articles_switzerland_de <- subset(articles, Country == "Switzerland" & Language == "de")
articles_uk_en <- subset(articles, Country == "UK")


set.seed(57)# setting a seed ensures that the random selection can be repeated in the same way
library(dplyr)
intercoder_set_switzerland_de <- sample_n(articles_switzerland_de, 10) #select 10 random rows
intercoder_set_uk_en <- sample_n(articles_uk_en, 10) #select 10 random rows
intercoder_set <- rbind(intercoder_set_switzerland_de, intercoder_set_uk_en)

```

We now add an empty column called `climate_activism_m`, so that coders can enter the manual codes.

```{r}

intercoder_set$climate_activism_m <- "" 

```

We then create several duplicates of the intercoder reliability set, one for each coder. We create separate files so that coders can so that everyone codes individually and does not peek by mistake.
To each of these sets we add the coder name in a new column called `coder_name`.

```{r}

intercoder_set_coder1 <- intercoder_set
intercoder_set_coder1$coder_name <- "MT"

intercoder_set_coder2 <- intercoder_set
intercoder_set_coder2$coder_name <- "KM"

intercoder_set_coder3 <- intercoder_set
intercoder_set_coder3$coder_name <- "JS"

intercoder_set_coder4 <- intercoder_set
intercoder_set_coder4$coder_name <- "KB"

intercoder_set_coder5 <- intercoder_set
intercoder_set_coder5$coder_name <- "PN"

intercoder_set_coder6 <- intercoder_set
intercoder_set_coder6$coder_name <- "BW"

intercoder_set_coder7 <- intercoder_set
intercoder_set_coder7$coder_name <- "AR"

intercoder_set_coder8 <- intercoder_set
intercoder_set_coder8$coder_name <- "SR"

intercoder_set_coder9 <- intercoder_set
intercoder_set_coder9$coder_name <- "EP"

intercoder_set_coder10 <- intercoder_set
intercoder_set_coder10$coder_name <- "MH"

intercoder_set_coder11 <- intercoder_set
intercoder_set_coder11$coder_name <- "CL"

```

We then want to save the data sets in google sheets. Detailed instructions about the conncection of **R** and **Google Sheets** can be found in  [this](https://googlesheets4.tidyverse.org/articles/drive-and-sheets.html) and [this ](https://googlesheets4.tidyverse.org/articles/drive-and-sheets.html) tutorial.

The two packages needed here are **googledrive** and **googlesheets4**.

```{r}

#install.packages("googledrive")
#install.packages("googlesheets4")
library(googledrive)
library(googlesheets4)

```

```{r}

# Authentication
drive_auth(email ="fabienne.lind@gmail.com")
gs4_auth(token = drive_token())
drive_user()

```

We now save the datasets for the intercoder reliability test as Google Sheets with the function `gs4_create`. 

```{r}

sheet_id1<- gs4_create("intercoder_set_coder1",sheets = intercoder_set_coder1)
sheet_id2<- gs4_create("intercoder_set_coder2",sheets = intercoder_set_coder2)
sheet_id3 <- gs4_create("intercoder_set_coder3",sheets = intercoder_set_coder3)
sheet_id4 <- gs4_create("intercoder_set_coder4",sheets = intercoder_set_coder4)
sheet_id5 <- gs4_create("intercoder_set_coder5",sheets = intercoder_set_coder5)
sheet_id6 <- gs4_create("intercoder_set_coder6",sheets = intercoder_set_coder6)
sheet_id7 <- gs4_create("intercoder_set_coder7",sheets = intercoder_set_coder7)
sheet_id8 <- gs4_create("intercoder_set_coder8",sheets = intercoder_set_coder8)
sheet_id9 <- gs4_create("intercoder_set_coder9",sheets = intercoder_set_coder9)
sheet_id10 <- gs4_create("intercoder_set_coder10",sheets = intercoder_set_coder10)
sheet_id11 <- gs4_create("intercoder_set_coder11",sheets = intercoder_set_coder11)

```

Ready to code? Please open just the one that was created for you. Read the column `text`. If the text is about climate activism insert `1` in the column `climate_activism_m`. Enter a `0` in `climate_activism_m` if the text is not about climate activism.

After you finished coding, we read all sheets back into Rstudio (now with manual classifications for `climate_activism_m`).

```{r}

intercoder_set_coder1c <- read_sheet(sheet_id1)
intercoder_set_coder2c <- read_sheet(sheet_id2)
intercoder_set_coder3c <- read_sheet(sheet_id3)
intercoder_set_coder4c <- read_sheet(sheet_id4)
intercoder_set_coder5c <- read_sheet(sheet_id5)
intercoder_set_coder6c <- read_sheet(sheet_id6)
intercoder_set_coder7c <- read_sheet(sheet_id7)
intercoder_set_coder8c <- read_sheet(sheet_id8)
intercoder_set_coder9c <- read_sheet(sheet_id9)
intercoder_set_coder10c <- read_sheet(sheet_id10)
intercoder_set_coder11c <- read_sheet(sheet_id11)

```

All dataframes are combined into one dataframe with the function `rbind`.

```{r}

reliability_set <- rbind(intercoder_set_coder1c, intercoder_set_coder2c, intercoder_set_coder3c, intercoder_set_coder4c,
                         intercoder_set_coder5c, intercoder_set_coder6c, intercoder_set_coder7c,
                         intercoder_set_coder8c,intercoder_set_coder9c, intercoder_set_coder10c) 

```

Too calculate the agreement between coders, we first restructure the `reliability_set` a bit (the different coders become variables). 'id' is the name of our id variable. 'coder_name' is the column with the different coder ids. And 'actors_m' is the variable for which we seek to test intercoder reliability.

```{r}

#install.packages("reshape2")
library(reshape2) 

reliability_restructured <- dcast(reliability_set, id ~ coder_name, value.var="climate_activism_m")

reliability_transp <- t(reliability_restructured) # transpose data frames (rows to columns, columns to rows)
reliability_matrix <- data.matrix(reliability_transp) # convert df.t to matrix 
reliability_matrix_final <- reliability_matrix[-1,] # delete first row of matrix

```

The package **irr** allows to calculate various coefficients of intercoder reliability. 
We calculate Krippendorff's alpha for this example.

```{r}

#install.packages("irr")
library(irr)  

alpha_de <- kripp.alpha(reliability_matrix_final, method ="nominal") # select the appropriate method, nominal is default,
alpha_de

```

If alpha is large enough, we consider the quality of our manual coding as sufficient. We can then start with the creation of a larger manual baseline to be compared with the dictionary classifications.

## Creating a manually coded baseline

We pick an equal amount of texts per case and language randomly. For this example we just pick 40 German (Switzerland) and 40 English (UK)

```{r}

#install.packages("dplyr")
library(dplyr)

set.seed(789)# setting a seed ensures that the random selection can be repeated in the same way
manual_set_switzerland_de <- sample_n(articles_switzerland_de, 40)
manual_set_uk_en <- sample_n(articles_uk_en, 40)
manual_set <- rbind(manual_set_switzerland_de, manual_set_uk_en)

```

We add again an empty column called `climate_activism_m`, for coders to enter the manual codes. This time, we also add an empty column for the coder names.

```{r}

manual_set$climate_activism_m <- "" 
manual_set$coder_name <- ""

```

We create a google sheet for the task with `gs4_create`. 

```{r}

sheet_id_manual<- gs4_create("manual_set", sheets = manual_set)

```

Please open the sheet in your browser. Enter a coding name (free to pick) in the column `coder_name` for a couple of rows first. Then start to enter 1 (climate actisvism mentioned) or 0 (not mentioned) in the column `climate_activism_m` for the rows with your coding name. Our goal is to finish coding of all artkicles.


After you finish coding, we read all sheets back into Rstudio (now with manual classifications for `climate_activism_m`).

```{r}

manual_set_coded <- read_sheet(sheet_id_manual)

```

We need to create a data set, where the manual and automated classifications are included.

```{r}

manual_set_coded <- subset(manual_set_coded, select = c("id", "climate_activism_m"))# we need only 2 columns from the manual set
articles_coded_d_m <- merge(manual_set_coded, articles_hits, by ="ID")
                           
```

## Compare automated with manual classifications 

We compare the automated classification (in column `climate_activism`) with the manual classifications (in column `climate_activism_m`) we use three metrics: Recall, Precision, and F1.
The metrics inform us about the quality of the dictionary. All three metrics range from 0 to 1. 
We assume that our manual classification identified all relevant articles (here: texts that are about climate activism).


To calculate the three metrics, we need first to create three new columns via some recoding. 

The column `Relevant_andRetrieved` includes a 1 if the manual coder and the dictionary coded 1. = True positive
The column `Relevant_notRetrieved` includes a 1 if the manual coder coded 1 but the dictionary coded 0. = False negative
The column `notRelevant_butRetrieved` includes a 1 if the manual coder coded 0 but the dictionary coded 1. = False positive

```{r}

articles_coded_d_m$Relevant_andRetrieved[articles_coded_d_m$climate_activism_m == 1 & articles_coded_d_m$climate_activism== 1 ] <- 1
articles_coded_d_m$Relevant_notRetrieved[articles_coded_d_m$climate_activism_m == 1 & articles_coded_d_m$climate_activism == 0 ] <- 1
articles_coded_d_m$notRelevant_butRetrieved[articles_coded_d_m$climate_activism_m == 0 & articles_coded_d_m$climate_activism == 1 ] <- 1

```

### Recall 

By inspecting recall we can say how many relevant articles are retrieved by the dictionary.
A recall of 1.0 means that our dictionary retrieved all relevant articles. 
A recall of 0.8 means that our dictionary retrieved 80% of all relevant articles. 

To obtain recall, we calculate:

```{r}

recall <- (sum(articles_coded_d_m$Relevant_andRetrieved, na.rm=TRUE))/(sum(articles_coded_d_m$Relevant_notRetrieved, na.rm=TRUE) + (sum(articles_coded_d_m$Relevant_andRetrieved, na.rm=TRUE)))
recall


```


### Precision 

By inspecting precision we can say how many retrieved articles are relevant.
A precision of 1,0 means that all articles retrieved by the dictionary are relevant. 
A precision of 0.8 means that 80% of the articles that our dictionary retrieved are relevant articles. 

To obtain precision, we calculate:

```{r}

precision <- (sum(articles_coded_d_m$Relevant_andRetrieved, na.rm=TRUE))/(sum(articles_coded_d_m$notRelevant_butRetrieved, na.rm=TRUE) + (sum(articles_coded_d_m$Relevant_andRetrieved, na.rm=TRUE)))
precision # 

```


### F1

F1 is the harmonic mean between recall and precision. 

To obtain F1, we calculate:

```{r}

F1 <- (2 * precision * recall)/(precision + recall)
F1

```

Questions: 

- Say we have a precision of .9 but a recall of .1, what does this mean for the quality of our dictionary?

- How are the results comparing cases and languages?

- What can we do to improve recall?

- What can we do to improve precision?



